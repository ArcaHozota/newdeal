// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"newdeal/ent/auth"
	"newdeal/ent/hymn"
	"newdeal/ent/hymnswork"
	"newdeal/ent/predicate"
	"newdeal/ent/role"
	"newdeal/ent/student"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuth      = "Auth"
	TypeHymn      = "Hymn"
	TypeHymnsWork = "HymnsWork"
	TypeRole      = "Role"
	TypeStudent   = "Student"
)

// AuthMutation represents an operation that mutates the Auth nodes in the graph.
type AuthMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	name           *string
	title          *string
	category_id    *int64
	addcategory_id *int64
	clearedFields  map[string]struct{}
	roles          map[int64]struct{}
	removedroles   map[int64]struct{}
	clearedroles   bool
	done           bool
	oldValue       func(context.Context) (*Auth, error)
	predicates     []predicate.Auth
}

var _ ent.Mutation = (*AuthMutation)(nil)

// authOption allows management of the mutation configuration using functional options.
type authOption func(*AuthMutation)

// newAuthMutation creates new mutation for the Auth entity.
func newAuthMutation(c config, op Op, opts ...authOption) *AuthMutation {
	m := &AuthMutation{
		config:        c,
		op:            op,
		typ:           TypeAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthID sets the ID field of the mutation.
func withAuthID(id int64) authOption {
	return func(m *AuthMutation) {
		var (
			err   error
			once  sync.Once
			value *Auth
		)
		m.oldValue = func(ctx context.Context) (*Auth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuth sets the old Auth of the mutation.
func withAuth(node *Auth) authOption {
	return func(m *AuthMutation) {
		m.oldValue = func(context.Context) (*Auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Auth entities.
func (m *AuthMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Auth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AuthMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AuthMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AuthMutation) ResetName() {
	m.name = nil
}

// SetTitle sets the "title" field.
func (m *AuthMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AuthMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AuthMutation) ResetTitle() {
	m.title = nil
}

// SetCategoryID sets the "category_id" field.
func (m *AuthMutation) SetCategoryID(i int64) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *AuthMutation) CategoryID() (r int64, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Auth entity.
// If the Auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthMutation) OldCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *AuthMutation) AddCategoryID(i int64) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *AuthMutation) AddedCategoryID() (r int64, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *AuthMutation) ClearCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	m.clearedFields[auth.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *AuthMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[auth.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *AuthMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
	delete(m.clearedFields, auth.FieldCategoryID)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *AuthMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *AuthMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *AuthMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *AuthMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *AuthMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *AuthMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *AuthMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the AuthMutation builder.
func (m *AuthMutation) Where(ps ...predicate.Auth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Auth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Auth).
func (m *AuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, auth.FieldName)
	}
	if m.title != nil {
		fields = append(fields, auth.FieldTitle)
	}
	if m.category_id != nil {
		fields = append(fields, auth.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldName:
		return m.Name()
	case auth.FieldTitle:
		return m.Title()
	case auth.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auth.FieldName:
		return m.OldName(ctx)
	case auth.FieldTitle:
		return m.OldTitle(ctx)
	case auth.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown Auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auth.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case auth.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case auth.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, auth.FieldCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auth.FieldCategoryID:
		return m.AddedCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auth.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auth.FieldCategoryID) {
		fields = append(fields, auth.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthMutation) ClearField(name string) error {
	switch name {
	case auth.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthMutation) ResetField(name string) error {
	switch name {
	case auth.FieldName:
		m.ResetName()
		return nil
	case auth.FieldTitle:
		m.ResetTitle()
		return nil
	case auth.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.roles != nil {
		edges = append(edges, auth.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auth.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedroles != nil {
		edges = append(edges, auth.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case auth.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedroles {
		edges = append(edges, auth.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthMutation) EdgeCleared(name string) bool {
	switch name {
	case auth.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthMutation) ResetEdge(name string) error {
	switch name {
	case auth.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Auth edge %s", name)
}

// HymnMutation represents an operation that mutates the Hymn nodes in the graph.
type HymnMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name_jp           *string
	name_kr           *string
	link              *string
	updated_time      *time.Time
	serif             *string
	visible_flg       *bool
	clearedFields     map[string]struct{}
	updated_by        *int64
	clearedupdated_by bool
	work              *int64
	clearedwork       bool
	done              bool
	oldValue          func(context.Context) (*Hymn, error)
	predicates        []predicate.Hymn
}

var _ ent.Mutation = (*HymnMutation)(nil)

// hymnOption allows management of the mutation configuration using functional options.
type hymnOption func(*HymnMutation)

// newHymnMutation creates new mutation for the Hymn entity.
func newHymnMutation(c config, op Op, opts ...hymnOption) *HymnMutation {
	m := &HymnMutation{
		config:        c,
		op:            op,
		typ:           TypeHymn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHymnID sets the ID field of the mutation.
func withHymnID(id int64) hymnOption {
	return func(m *HymnMutation) {
		var (
			err   error
			once  sync.Once
			value *Hymn
		)
		m.oldValue = func(ctx context.Context) (*Hymn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hymn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHymn sets the old Hymn of the mutation.
func withHymn(node *Hymn) hymnOption {
	return func(m *HymnMutation) {
		m.oldValue = func(context.Context) (*Hymn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HymnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HymnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hymn entities.
func (m *HymnMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HymnMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HymnMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hymn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameJp sets the "name_jp" field.
func (m *HymnMutation) SetNameJp(s string) {
	m.name_jp = &s
}

// NameJp returns the value of the "name_jp" field in the mutation.
func (m *HymnMutation) NameJp() (r string, exists bool) {
	v := m.name_jp
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJp returns the old "name_jp" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldNameJp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJp: %w", err)
	}
	return oldValue.NameJp, nil
}

// ResetNameJp resets all changes to the "name_jp" field.
func (m *HymnMutation) ResetNameJp() {
	m.name_jp = nil
}

// SetNameKr sets the "name_kr" field.
func (m *HymnMutation) SetNameKr(s string) {
	m.name_kr = &s
}

// NameKr returns the value of the "name_kr" field in the mutation.
func (m *HymnMutation) NameKr() (r string, exists bool) {
	v := m.name_kr
	if v == nil {
		return
	}
	return *v, true
}

// OldNameKr returns the old "name_kr" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldNameKr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameKr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameKr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameKr: %w", err)
	}
	return oldValue.NameKr, nil
}

// ResetNameKr resets all changes to the "name_kr" field.
func (m *HymnMutation) ResetNameKr() {
	m.name_kr = nil
}

// SetLink sets the "link" field.
func (m *HymnMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *HymnMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *HymnMutation) ClearLink() {
	m.link = nil
	m.clearedFields[hymn.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *HymnMutation) LinkCleared() bool {
	_, ok := m.clearedFields[hymn.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *HymnMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, hymn.FieldLink)
}

// SetUpdatedUser sets the "updated_user" field.
func (m *HymnMutation) SetUpdatedUser(i int64) {
	m.updated_by = &i
}

// UpdatedUser returns the value of the "updated_user" field in the mutation.
func (m *HymnMutation) UpdatedUser() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUser returns the old "updated_user" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldUpdatedUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUser: %w", err)
	}
	return oldValue.UpdatedUser, nil
}

// ResetUpdatedUser resets all changes to the "updated_user" field.
func (m *HymnMutation) ResetUpdatedUser() {
	m.updated_by = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *HymnMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *HymnMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *HymnMutation) ResetUpdatedTime() {
	m.updated_time = nil
}

// SetSerif sets the "serif" field.
func (m *HymnMutation) SetSerif(s string) {
	m.serif = &s
}

// Serif returns the value of the "serif" field in the mutation.
func (m *HymnMutation) Serif() (r string, exists bool) {
	v := m.serif
	if v == nil {
		return
	}
	return *v, true
}

// OldSerif returns the old "serif" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldSerif(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerif is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerif requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerif: %w", err)
	}
	return oldValue.Serif, nil
}

// ClearSerif clears the value of the "serif" field.
func (m *HymnMutation) ClearSerif() {
	m.serif = nil
	m.clearedFields[hymn.FieldSerif] = struct{}{}
}

// SerifCleared returns if the "serif" field was cleared in this mutation.
func (m *HymnMutation) SerifCleared() bool {
	_, ok := m.clearedFields[hymn.FieldSerif]
	return ok
}

// ResetSerif resets all changes to the "serif" field.
func (m *HymnMutation) ResetSerif() {
	m.serif = nil
	delete(m.clearedFields, hymn.FieldSerif)
}

// SetVisibleFlg sets the "visible_flg" field.
func (m *HymnMutation) SetVisibleFlg(b bool) {
	m.visible_flg = &b
}

// VisibleFlg returns the value of the "visible_flg" field in the mutation.
func (m *HymnMutation) VisibleFlg() (r bool, exists bool) {
	v := m.visible_flg
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleFlg returns the old "visible_flg" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldVisibleFlg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleFlg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleFlg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleFlg: %w", err)
	}
	return oldValue.VisibleFlg, nil
}

// ResetVisibleFlg resets all changes to the "visible_flg" field.
func (m *HymnMutation) ResetVisibleFlg() {
	m.visible_flg = nil
}

// SetUpdatedByID sets the "updated_by" edge to the Student entity by id.
func (m *HymnMutation) SetUpdatedByID(id int64) {
	m.updated_by = &id
}

// ClearUpdatedBy clears the "updated_by" edge to the Student entity.
func (m *HymnMutation) ClearUpdatedBy() {
	m.clearedupdated_by = true
	m.clearedFields[hymn.FieldUpdatedUser] = struct{}{}
}

// UpdatedByCleared reports if the "updated_by" edge to the Student entity was cleared.
func (m *HymnMutation) UpdatedByCleared() bool {
	return m.clearedupdated_by
}

// UpdatedByID returns the "updated_by" edge ID in the mutation.
func (m *HymnMutation) UpdatedByID() (id int64, exists bool) {
	if m.updated_by != nil {
		return *m.updated_by, true
	}
	return
}

// UpdatedByIDs returns the "updated_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByID instead. It exists only for internal usage by the builders.
func (m *HymnMutation) UpdatedByIDs() (ids []int64) {
	if id := m.updated_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedBy resets all changes to the "updated_by" edge.
func (m *HymnMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.clearedupdated_by = false
}

// SetWorkID sets the "work" edge to the HymnsWork entity by id.
func (m *HymnMutation) SetWorkID(id int64) {
	m.work = &id
}

// ClearWork clears the "work" edge to the HymnsWork entity.
func (m *HymnMutation) ClearWork() {
	m.clearedwork = true
}

// WorkCleared reports if the "work" edge to the HymnsWork entity was cleared.
func (m *HymnMutation) WorkCleared() bool {
	return m.clearedwork
}

// WorkID returns the "work" edge ID in the mutation.
func (m *HymnMutation) WorkID() (id int64, exists bool) {
	if m.work != nil {
		return *m.work, true
	}
	return
}

// WorkIDs returns the "work" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkID instead. It exists only for internal usage by the builders.
func (m *HymnMutation) WorkIDs() (ids []int64) {
	if id := m.work; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWork resets all changes to the "work" edge.
func (m *HymnMutation) ResetWork() {
	m.work = nil
	m.clearedwork = false
}

// Where appends a list predicates to the HymnMutation builder.
func (m *HymnMutation) Where(ps ...predicate.Hymn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HymnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HymnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hymn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HymnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HymnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hymn).
func (m *HymnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HymnMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name_jp != nil {
		fields = append(fields, hymn.FieldNameJp)
	}
	if m.name_kr != nil {
		fields = append(fields, hymn.FieldNameKr)
	}
	if m.link != nil {
		fields = append(fields, hymn.FieldLink)
	}
	if m.updated_by != nil {
		fields = append(fields, hymn.FieldUpdatedUser)
	}
	if m.updated_time != nil {
		fields = append(fields, hymn.FieldUpdatedTime)
	}
	if m.serif != nil {
		fields = append(fields, hymn.FieldSerif)
	}
	if m.visible_flg != nil {
		fields = append(fields, hymn.FieldVisibleFlg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HymnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hymn.FieldNameJp:
		return m.NameJp()
	case hymn.FieldNameKr:
		return m.NameKr()
	case hymn.FieldLink:
		return m.Link()
	case hymn.FieldUpdatedUser:
		return m.UpdatedUser()
	case hymn.FieldUpdatedTime:
		return m.UpdatedTime()
	case hymn.FieldSerif:
		return m.Serif()
	case hymn.FieldVisibleFlg:
		return m.VisibleFlg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HymnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hymn.FieldNameJp:
		return m.OldNameJp(ctx)
	case hymn.FieldNameKr:
		return m.OldNameKr(ctx)
	case hymn.FieldLink:
		return m.OldLink(ctx)
	case hymn.FieldUpdatedUser:
		return m.OldUpdatedUser(ctx)
	case hymn.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case hymn.FieldSerif:
		return m.OldSerif(ctx)
	case hymn.FieldVisibleFlg:
		return m.OldVisibleFlg(ctx)
	}
	return nil, fmt.Errorf("unknown Hymn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hymn.FieldNameJp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJp(v)
		return nil
	case hymn.FieldNameKr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameKr(v)
		return nil
	case hymn.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case hymn.FieldUpdatedUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUser(v)
		return nil
	case hymn.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case hymn.FieldSerif:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerif(v)
		return nil
	case hymn.FieldVisibleFlg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleFlg(v)
		return nil
	}
	return fmt.Errorf("unknown Hymn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HymnMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HymnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Hymn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HymnMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hymn.FieldLink) {
		fields = append(fields, hymn.FieldLink)
	}
	if m.FieldCleared(hymn.FieldSerif) {
		fields = append(fields, hymn.FieldSerif)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HymnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HymnMutation) ClearField(name string) error {
	switch name {
	case hymn.FieldLink:
		m.ClearLink()
		return nil
	case hymn.FieldSerif:
		m.ClearSerif()
		return nil
	}
	return fmt.Errorf("unknown Hymn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HymnMutation) ResetField(name string) error {
	switch name {
	case hymn.FieldNameJp:
		m.ResetNameJp()
		return nil
	case hymn.FieldNameKr:
		m.ResetNameKr()
		return nil
	case hymn.FieldLink:
		m.ResetLink()
		return nil
	case hymn.FieldUpdatedUser:
		m.ResetUpdatedUser()
		return nil
	case hymn.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case hymn.FieldSerif:
		m.ResetSerif()
		return nil
	case hymn.FieldVisibleFlg:
		m.ResetVisibleFlg()
		return nil
	}
	return fmt.Errorf("unknown Hymn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HymnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.updated_by != nil {
		edges = append(edges, hymn.EdgeUpdatedBy)
	}
	if m.work != nil {
		edges = append(edges, hymn.EdgeWork)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HymnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hymn.EdgeUpdatedBy:
		if id := m.updated_by; id != nil {
			return []ent.Value{*id}
		}
	case hymn.EdgeWork:
		if id := m.work; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HymnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HymnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HymnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedupdated_by {
		edges = append(edges, hymn.EdgeUpdatedBy)
	}
	if m.clearedwork {
		edges = append(edges, hymn.EdgeWork)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HymnMutation) EdgeCleared(name string) bool {
	switch name {
	case hymn.EdgeUpdatedBy:
		return m.clearedupdated_by
	case hymn.EdgeWork:
		return m.clearedwork
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HymnMutation) ClearEdge(name string) error {
	switch name {
	case hymn.EdgeUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case hymn.EdgeWork:
		m.ClearWork()
		return nil
	}
	return fmt.Errorf("unknown Hymn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HymnMutation) ResetEdge(name string) error {
	switch name {
	case hymn.EdgeUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hymn.EdgeWork:
		m.ResetWork()
		return nil
	}
	return fmt.Errorf("unknown Hymn edge %s", name)
}

// HymnsWorkMutation represents an operation that mutates the HymnsWork nodes in the graph.
type HymnsWorkMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	score              *[]byte
	name_jp_rational   *string
	updated_time       *time.Time
	biko               *string
	clearedFields      map[string]struct{}
	linked_hymn        *int64
	clearedlinked_hymn bool
	done               bool
	oldValue           func(context.Context) (*HymnsWork, error)
	predicates         []predicate.HymnsWork
}

var _ ent.Mutation = (*HymnsWorkMutation)(nil)

// hymnsworkOption allows management of the mutation configuration using functional options.
type hymnsworkOption func(*HymnsWorkMutation)

// newHymnsWorkMutation creates new mutation for the HymnsWork entity.
func newHymnsWorkMutation(c config, op Op, opts ...hymnsworkOption) *HymnsWorkMutation {
	m := &HymnsWorkMutation{
		config:        c,
		op:            op,
		typ:           TypeHymnsWork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHymnsWorkID sets the ID field of the mutation.
func withHymnsWorkID(id int64) hymnsworkOption {
	return func(m *HymnsWorkMutation) {
		var (
			err   error
			once  sync.Once
			value *HymnsWork
		)
		m.oldValue = func(ctx context.Context) (*HymnsWork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HymnsWork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHymnsWork sets the old HymnsWork of the mutation.
func withHymnsWork(node *HymnsWork) hymnsworkOption {
	return func(m *HymnsWorkMutation) {
		m.oldValue = func(context.Context) (*HymnsWork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HymnsWorkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HymnsWorkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HymnsWork entities.
func (m *HymnsWorkMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HymnsWorkMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HymnsWorkMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HymnsWork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkID sets the "work_id" field.
func (m *HymnsWorkMutation) SetWorkID(i int64) {
	m.linked_hymn = &i
}

// WorkID returns the value of the "work_id" field in the mutation.
func (m *HymnsWorkMutation) WorkID() (r int64, exists bool) {
	v := m.linked_hymn
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkID returns the old "work_id" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldWorkID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkID: %w", err)
	}
	return oldValue.WorkID, nil
}

// ResetWorkID resets all changes to the "work_id" field.
func (m *HymnsWorkMutation) ResetWorkID() {
	m.linked_hymn = nil
}

// SetScore sets the "score" field.
func (m *HymnsWorkMutation) SetScore(b []byte) {
	m.score = &b
}

// Score returns the value of the "score" field in the mutation.
func (m *HymnsWorkMutation) Score() (r []byte, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldScore(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// ClearScore clears the value of the "score" field.
func (m *HymnsWorkMutation) ClearScore() {
	m.score = nil
	m.clearedFields[hymnswork.FieldScore] = struct{}{}
}

// ScoreCleared returns if the "score" field was cleared in this mutation.
func (m *HymnsWorkMutation) ScoreCleared() bool {
	_, ok := m.clearedFields[hymnswork.FieldScore]
	return ok
}

// ResetScore resets all changes to the "score" field.
func (m *HymnsWorkMutation) ResetScore() {
	m.score = nil
	delete(m.clearedFields, hymnswork.FieldScore)
}

// SetNameJpRational sets the "name_jp_rational" field.
func (m *HymnsWorkMutation) SetNameJpRational(s string) {
	m.name_jp_rational = &s
}

// NameJpRational returns the value of the "name_jp_rational" field in the mutation.
func (m *HymnsWorkMutation) NameJpRational() (r string, exists bool) {
	v := m.name_jp_rational
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJpRational returns the old "name_jp_rational" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldNameJpRational(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJpRational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJpRational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJpRational: %w", err)
	}
	return oldValue.NameJpRational, nil
}

// ClearNameJpRational clears the value of the "name_jp_rational" field.
func (m *HymnsWorkMutation) ClearNameJpRational() {
	m.name_jp_rational = nil
	m.clearedFields[hymnswork.FieldNameJpRational] = struct{}{}
}

// NameJpRationalCleared returns if the "name_jp_rational" field was cleared in this mutation.
func (m *HymnsWorkMutation) NameJpRationalCleared() bool {
	_, ok := m.clearedFields[hymnswork.FieldNameJpRational]
	return ok
}

// ResetNameJpRational resets all changes to the "name_jp_rational" field.
func (m *HymnsWorkMutation) ResetNameJpRational() {
	m.name_jp_rational = nil
	delete(m.clearedFields, hymnswork.FieldNameJpRational)
}

// SetUpdatedTime sets the "updated_time" field.
func (m *HymnsWorkMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *HymnsWorkMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *HymnsWorkMutation) ResetUpdatedTime() {
	m.updated_time = nil
}

// SetBiko sets the "biko" field.
func (m *HymnsWorkMutation) SetBiko(s string) {
	m.biko = &s
}

// Biko returns the value of the "biko" field in the mutation.
func (m *HymnsWorkMutation) Biko() (r string, exists bool) {
	v := m.biko
	if v == nil {
		return
	}
	return *v, true
}

// OldBiko returns the old "biko" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldBiko(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiko is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiko requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiko: %w", err)
	}
	return oldValue.Biko, nil
}

// ClearBiko clears the value of the "biko" field.
func (m *HymnsWorkMutation) ClearBiko() {
	m.biko = nil
	m.clearedFields[hymnswork.FieldBiko] = struct{}{}
}

// BikoCleared returns if the "biko" field was cleared in this mutation.
func (m *HymnsWorkMutation) BikoCleared() bool {
	_, ok := m.clearedFields[hymnswork.FieldBiko]
	return ok
}

// ResetBiko resets all changes to the "biko" field.
func (m *HymnsWorkMutation) ResetBiko() {
	m.biko = nil
	delete(m.clearedFields, hymnswork.FieldBiko)
}

// SetLinkedHymnID sets the "linked_hymn" edge to the Hymn entity by id.
func (m *HymnsWorkMutation) SetLinkedHymnID(id int64) {
	m.linked_hymn = &id
}

// ClearLinkedHymn clears the "linked_hymn" edge to the Hymn entity.
func (m *HymnsWorkMutation) ClearLinkedHymn() {
	m.clearedlinked_hymn = true
	m.clearedFields[hymnswork.FieldWorkID] = struct{}{}
}

// LinkedHymnCleared reports if the "linked_hymn" edge to the Hymn entity was cleared.
func (m *HymnsWorkMutation) LinkedHymnCleared() bool {
	return m.clearedlinked_hymn
}

// LinkedHymnID returns the "linked_hymn" edge ID in the mutation.
func (m *HymnsWorkMutation) LinkedHymnID() (id int64, exists bool) {
	if m.linked_hymn != nil {
		return *m.linked_hymn, true
	}
	return
}

// LinkedHymnIDs returns the "linked_hymn" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LinkedHymnID instead. It exists only for internal usage by the builders.
func (m *HymnsWorkMutation) LinkedHymnIDs() (ids []int64) {
	if id := m.linked_hymn; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLinkedHymn resets all changes to the "linked_hymn" edge.
func (m *HymnsWorkMutation) ResetLinkedHymn() {
	m.linked_hymn = nil
	m.clearedlinked_hymn = false
}

// Where appends a list predicates to the HymnsWorkMutation builder.
func (m *HymnsWorkMutation) Where(ps ...predicate.HymnsWork) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HymnsWorkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HymnsWorkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HymnsWork, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HymnsWorkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HymnsWorkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HymnsWork).
func (m *HymnsWorkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HymnsWorkMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.linked_hymn != nil {
		fields = append(fields, hymnswork.FieldWorkID)
	}
	if m.score != nil {
		fields = append(fields, hymnswork.FieldScore)
	}
	if m.name_jp_rational != nil {
		fields = append(fields, hymnswork.FieldNameJpRational)
	}
	if m.updated_time != nil {
		fields = append(fields, hymnswork.FieldUpdatedTime)
	}
	if m.biko != nil {
		fields = append(fields, hymnswork.FieldBiko)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HymnsWorkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hymnswork.FieldWorkID:
		return m.WorkID()
	case hymnswork.FieldScore:
		return m.Score()
	case hymnswork.FieldNameJpRational:
		return m.NameJpRational()
	case hymnswork.FieldUpdatedTime:
		return m.UpdatedTime()
	case hymnswork.FieldBiko:
		return m.Biko()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HymnsWorkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hymnswork.FieldWorkID:
		return m.OldWorkID(ctx)
	case hymnswork.FieldScore:
		return m.OldScore(ctx)
	case hymnswork.FieldNameJpRational:
		return m.OldNameJpRational(ctx)
	case hymnswork.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case hymnswork.FieldBiko:
		return m.OldBiko(ctx)
	}
	return nil, fmt.Errorf("unknown HymnsWork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnsWorkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hymnswork.FieldWorkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkID(v)
		return nil
	case hymnswork.FieldScore:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case hymnswork.FieldNameJpRational:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJpRational(v)
		return nil
	case hymnswork.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case hymnswork.FieldBiko:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiko(v)
		return nil
	}
	return fmt.Errorf("unknown HymnsWork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HymnsWorkMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HymnsWorkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnsWorkMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HymnsWork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HymnsWorkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hymnswork.FieldScore) {
		fields = append(fields, hymnswork.FieldScore)
	}
	if m.FieldCleared(hymnswork.FieldNameJpRational) {
		fields = append(fields, hymnswork.FieldNameJpRational)
	}
	if m.FieldCleared(hymnswork.FieldBiko) {
		fields = append(fields, hymnswork.FieldBiko)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HymnsWorkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HymnsWorkMutation) ClearField(name string) error {
	switch name {
	case hymnswork.FieldScore:
		m.ClearScore()
		return nil
	case hymnswork.FieldNameJpRational:
		m.ClearNameJpRational()
		return nil
	case hymnswork.FieldBiko:
		m.ClearBiko()
		return nil
	}
	return fmt.Errorf("unknown HymnsWork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HymnsWorkMutation) ResetField(name string) error {
	switch name {
	case hymnswork.FieldWorkID:
		m.ResetWorkID()
		return nil
	case hymnswork.FieldScore:
		m.ResetScore()
		return nil
	case hymnswork.FieldNameJpRational:
		m.ResetNameJpRational()
		return nil
	case hymnswork.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case hymnswork.FieldBiko:
		m.ResetBiko()
		return nil
	}
	return fmt.Errorf("unknown HymnsWork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HymnsWorkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.linked_hymn != nil {
		edges = append(edges, hymnswork.EdgeLinkedHymn)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HymnsWorkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hymnswork.EdgeLinkedHymn:
		if id := m.linked_hymn; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HymnsWorkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HymnsWorkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HymnsWorkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlinked_hymn {
		edges = append(edges, hymnswork.EdgeLinkedHymn)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HymnsWorkMutation) EdgeCleared(name string) bool {
	switch name {
	case hymnswork.EdgeLinkedHymn:
		return m.clearedlinked_hymn
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HymnsWorkMutation) ClearEdge(name string) error {
	switch name {
	case hymnswork.EdgeLinkedHymn:
		m.ClearLinkedHymn()
		return nil
	}
	return fmt.Errorf("unknown HymnsWork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HymnsWorkMutation) ResetEdge(name string) error {
	switch name {
	case hymnswork.EdgeLinkedHymn:
		m.ResetLinkedHymn()
		return nil
	}
	return fmt.Errorf("unknown HymnsWork edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	name           *string
	visible_flg    *bool
	clearedFields  map[string]struct{}
	student        map[int64]struct{}
	removedstudent map[int64]struct{}
	clearedstudent bool
	auths          map[int64]struct{}
	removedauths   map[int64]struct{}
	clearedauths   bool
	done           bool
	oldValue       func(context.Context) (*Role, error)
	predicates     []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetVisibleFlg sets the "visible_flg" field.
func (m *RoleMutation) SetVisibleFlg(b bool) {
	m.visible_flg = &b
}

// VisibleFlg returns the value of the "visible_flg" field in the mutation.
func (m *RoleMutation) VisibleFlg() (r bool, exists bool) {
	v := m.visible_flg
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleFlg returns the old "visible_flg" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldVisibleFlg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleFlg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleFlg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleFlg: %w", err)
	}
	return oldValue.VisibleFlg, nil
}

// ResetVisibleFlg resets all changes to the "visible_flg" field.
func (m *RoleMutation) ResetVisibleFlg() {
	m.visible_flg = nil
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *RoleMutation) AddStudentIDs(ids ...int64) {
	if m.student == nil {
		m.student = make(map[int64]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *RoleMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *RoleMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *RoleMutation) RemoveStudentIDs(ids ...int64) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *RoleMutation) RemovedStudentIDs() (ids []int64) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *RoleMutation) StudentIDs() (ids []int64) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *RoleMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// AddAuthIDs adds the "auths" edge to the Auth entity by ids.
func (m *RoleMutation) AddAuthIDs(ids ...int64) {
	if m.auths == nil {
		m.auths = make(map[int64]struct{})
	}
	for i := range ids {
		m.auths[ids[i]] = struct{}{}
	}
}

// ClearAuths clears the "auths" edge to the Auth entity.
func (m *RoleMutation) ClearAuths() {
	m.clearedauths = true
}

// AuthsCleared reports if the "auths" edge to the Auth entity was cleared.
func (m *RoleMutation) AuthsCleared() bool {
	return m.clearedauths
}

// RemoveAuthIDs removes the "auths" edge to the Auth entity by IDs.
func (m *RoleMutation) RemoveAuthIDs(ids ...int64) {
	if m.removedauths == nil {
		m.removedauths = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.auths, ids[i])
		m.removedauths[ids[i]] = struct{}{}
	}
}

// RemovedAuths returns the removed IDs of the "auths" edge to the Auth entity.
func (m *RoleMutation) RemovedAuthsIDs() (ids []int64) {
	for id := range m.removedauths {
		ids = append(ids, id)
	}
	return
}

// AuthsIDs returns the "auths" edge IDs in the mutation.
func (m *RoleMutation) AuthsIDs() (ids []int64) {
	for id := range m.auths {
		ids = append(ids, id)
	}
	return
}

// ResetAuths resets all changes to the "auths" edge.
func (m *RoleMutation) ResetAuths() {
	m.auths = nil
	m.clearedauths = false
	m.removedauths = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.visible_flg != nil {
		fields = append(fields, role.FieldVisibleFlg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldVisibleFlg:
		return m.VisibleFlg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldVisibleFlg:
		return m.OldVisibleFlg(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldVisibleFlg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleFlg(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldVisibleFlg:
		m.ResetVisibleFlg()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, role.EdgeStudent)
	}
	if m.auths != nil {
		edges = append(edges, role.EdgeAuths)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAuths:
		ids := make([]ent.Value, 0, len(m.auths))
		for id := range m.auths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstudent != nil {
		edges = append(edges, role.EdgeStudent)
	}
	if m.removedauths != nil {
		edges = append(edges, role.EdgeAuths)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeAuths:
		ids := make([]ent.Value, 0, len(m.removedauths))
		for id := range m.removedauths {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, role.EdgeStudent)
	}
	if m.clearedauths {
		edges = append(edges, role.EdgeAuths)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeStudent:
		return m.clearedstudent
	case role.EdgeAuths:
		return m.clearedauths
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeStudent:
		m.ResetStudent()
		return nil
	case role.EdgeAuths:
		m.ResetAuths()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	login_account        *string
	password             *string
	username             *string
	date_of_birth        *time.Time
	email                *string
	updated_time         *time.Time
	visible_flg          *bool
	clearedFields        map[string]struct{}
	updated_hymns        map[int64]struct{}
	removedupdated_hymns map[int64]struct{}
	clearedupdated_hymns bool
	roled_student        *int64
	clearedroled_student bool
	done                 bool
	oldValue             func(context.Context) (*Student, error)
	predicates           []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id int64) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLoginAccount sets the "login_account" field.
func (m *StudentMutation) SetLoginAccount(s string) {
	m.login_account = &s
}

// LoginAccount returns the value of the "login_account" field in the mutation.
func (m *StudentMutation) LoginAccount() (r string, exists bool) {
	v := m.login_account
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginAccount returns the old "login_account" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldLoginAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginAccount: %w", err)
	}
	return oldValue.LoginAccount, nil
}

// ResetLoginAccount resets all changes to the "login_account" field.
func (m *StudentMutation) ResetLoginAccount() {
	m.login_account = nil
}

// SetPassword sets the "password" field.
func (m *StudentMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *StudentMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *StudentMutation) ResetPassword() {
	m.password = nil
}

// SetUsername sets the "username" field.
func (m *StudentMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *StudentMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *StudentMutation) ResetUsername() {
	m.username = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *StudentMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *StudentMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *StudentMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
}

// SetEmail sets the "email" field.
func (m *StudentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StudentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *StudentMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[student.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *StudentMutation) EmailCleared() bool {
	_, ok := m.clearedFields[student.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *StudentMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, student.FieldEmail)
}

// SetRoleID sets the "role_id" field.
func (m *StudentMutation) SetRoleID(i int64) {
	m.roled_student = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *StudentMutation) RoleID() (r int64, exists bool) {
	v := m.roled_student
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldRoleID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *StudentMutation) ResetRoleID() {
	m.roled_student = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *StudentMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *StudentMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ClearUpdatedTime clears the value of the "updated_time" field.
func (m *StudentMutation) ClearUpdatedTime() {
	m.updated_time = nil
	m.clearedFields[student.FieldUpdatedTime] = struct{}{}
}

// UpdatedTimeCleared returns if the "updated_time" field was cleared in this mutation.
func (m *StudentMutation) UpdatedTimeCleared() bool {
	_, ok := m.clearedFields[student.FieldUpdatedTime]
	return ok
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *StudentMutation) ResetUpdatedTime() {
	m.updated_time = nil
	delete(m.clearedFields, student.FieldUpdatedTime)
}

// SetVisibleFlg sets the "visible_flg" field.
func (m *StudentMutation) SetVisibleFlg(b bool) {
	m.visible_flg = &b
}

// VisibleFlg returns the value of the "visible_flg" field in the mutation.
func (m *StudentMutation) VisibleFlg() (r bool, exists bool) {
	v := m.visible_flg
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleFlg returns the old "visible_flg" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldVisibleFlg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleFlg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleFlg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleFlg: %w", err)
	}
	return oldValue.VisibleFlg, nil
}

// ResetVisibleFlg resets all changes to the "visible_flg" field.
func (m *StudentMutation) ResetVisibleFlg() {
	m.visible_flg = nil
}

// AddUpdatedHymnIDs adds the "updated_hymns" edge to the Hymn entity by ids.
func (m *StudentMutation) AddUpdatedHymnIDs(ids ...int64) {
	if m.updated_hymns == nil {
		m.updated_hymns = make(map[int64]struct{})
	}
	for i := range ids {
		m.updated_hymns[ids[i]] = struct{}{}
	}
}

// ClearUpdatedHymns clears the "updated_hymns" edge to the Hymn entity.
func (m *StudentMutation) ClearUpdatedHymns() {
	m.clearedupdated_hymns = true
}

// UpdatedHymnsCleared reports if the "updated_hymns" edge to the Hymn entity was cleared.
func (m *StudentMutation) UpdatedHymnsCleared() bool {
	return m.clearedupdated_hymns
}

// RemoveUpdatedHymnIDs removes the "updated_hymns" edge to the Hymn entity by IDs.
func (m *StudentMutation) RemoveUpdatedHymnIDs(ids ...int64) {
	if m.removedupdated_hymns == nil {
		m.removedupdated_hymns = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.updated_hymns, ids[i])
		m.removedupdated_hymns[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedHymns returns the removed IDs of the "updated_hymns" edge to the Hymn entity.
func (m *StudentMutation) RemovedUpdatedHymnsIDs() (ids []int64) {
	for id := range m.removedupdated_hymns {
		ids = append(ids, id)
	}
	return
}

// UpdatedHymnsIDs returns the "updated_hymns" edge IDs in the mutation.
func (m *StudentMutation) UpdatedHymnsIDs() (ids []int64) {
	for id := range m.updated_hymns {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedHymns resets all changes to the "updated_hymns" edge.
func (m *StudentMutation) ResetUpdatedHymns() {
	m.updated_hymns = nil
	m.clearedupdated_hymns = false
	m.removedupdated_hymns = nil
}

// SetRoledStudentID sets the "roled_student" edge to the Role entity by id.
func (m *StudentMutation) SetRoledStudentID(id int64) {
	m.roled_student = &id
}

// ClearRoledStudent clears the "roled_student" edge to the Role entity.
func (m *StudentMutation) ClearRoledStudent() {
	m.clearedroled_student = true
	m.clearedFields[student.FieldRoleID] = struct{}{}
}

// RoledStudentCleared reports if the "roled_student" edge to the Role entity was cleared.
func (m *StudentMutation) RoledStudentCleared() bool {
	return m.clearedroled_student
}

// RoledStudentID returns the "roled_student" edge ID in the mutation.
func (m *StudentMutation) RoledStudentID() (id int64, exists bool) {
	if m.roled_student != nil {
		return *m.roled_student, true
	}
	return
}

// RoledStudentIDs returns the "roled_student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoledStudentID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) RoledStudentIDs() (ids []int64) {
	if id := m.roled_student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoledStudent resets all changes to the "roled_student" edge.
func (m *StudentMutation) ResetRoledStudent() {
	m.roled_student = nil
	m.clearedroled_student = false
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.login_account != nil {
		fields = append(fields, student.FieldLoginAccount)
	}
	if m.password != nil {
		fields = append(fields, student.FieldPassword)
	}
	if m.username != nil {
		fields = append(fields, student.FieldUsername)
	}
	if m.date_of_birth != nil {
		fields = append(fields, student.FieldDateOfBirth)
	}
	if m.email != nil {
		fields = append(fields, student.FieldEmail)
	}
	if m.roled_student != nil {
		fields = append(fields, student.FieldRoleID)
	}
	if m.updated_time != nil {
		fields = append(fields, student.FieldUpdatedTime)
	}
	if m.visible_flg != nil {
		fields = append(fields, student.FieldVisibleFlg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldLoginAccount:
		return m.LoginAccount()
	case student.FieldPassword:
		return m.Password()
	case student.FieldUsername:
		return m.Username()
	case student.FieldDateOfBirth:
		return m.DateOfBirth()
	case student.FieldEmail:
		return m.Email()
	case student.FieldRoleID:
		return m.RoleID()
	case student.FieldUpdatedTime:
		return m.UpdatedTime()
	case student.FieldVisibleFlg:
		return m.VisibleFlg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldLoginAccount:
		return m.OldLoginAccount(ctx)
	case student.FieldPassword:
		return m.OldPassword(ctx)
	case student.FieldUsername:
		return m.OldUsername(ctx)
	case student.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case student.FieldEmail:
		return m.OldEmail(ctx)
	case student.FieldRoleID:
		return m.OldRoleID(ctx)
	case student.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case student.FieldVisibleFlg:
		return m.OldVisibleFlg(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldLoginAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginAccount(v)
		return nil
	case student.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case student.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case student.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case student.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case student.FieldRoleID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case student.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case student.FieldVisibleFlg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleFlg(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(student.FieldEmail) {
		fields = append(fields, student.FieldEmail)
	}
	if m.FieldCleared(student.FieldUpdatedTime) {
		fields = append(fields, student.FieldUpdatedTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	switch name {
	case student.FieldEmail:
		m.ClearEmail()
		return nil
	case student.FieldUpdatedTime:
		m.ClearUpdatedTime()
		return nil
	}
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldLoginAccount:
		m.ResetLoginAccount()
		return nil
	case student.FieldPassword:
		m.ResetPassword()
		return nil
	case student.FieldUsername:
		m.ResetUsername()
		return nil
	case student.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case student.FieldEmail:
		m.ResetEmail()
		return nil
	case student.FieldRoleID:
		m.ResetRoleID()
		return nil
	case student.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case student.FieldVisibleFlg:
		m.ResetVisibleFlg()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.updated_hymns != nil {
		edges = append(edges, student.EdgeUpdatedHymns)
	}
	if m.roled_student != nil {
		edges = append(edges, student.EdgeRoledStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeUpdatedHymns:
		ids := make([]ent.Value, 0, len(m.updated_hymns))
		for id := range m.updated_hymns {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeRoledStudent:
		if id := m.roled_student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedupdated_hymns != nil {
		edges = append(edges, student.EdgeUpdatedHymns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeUpdatedHymns:
		ids := make([]ent.Value, 0, len(m.removedupdated_hymns))
		for id := range m.removedupdated_hymns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedupdated_hymns {
		edges = append(edges, student.EdgeUpdatedHymns)
	}
	if m.clearedroled_student {
		edges = append(edges, student.EdgeRoledStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeUpdatedHymns:
		return m.clearedupdated_hymns
	case student.EdgeRoledStudent:
		return m.clearedroled_student
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeRoledStudent:
		m.ClearRoledStudent()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeUpdatedHymns:
		m.ResetUpdatedHymns()
		return nil
	case student.EdgeRoledStudent:
		m.ResetRoledStudent()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}
