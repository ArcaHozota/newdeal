// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"newdeal/ent/hymn"
	"newdeal/ent/hymnswork"
	"newdeal/ent/predicate"
	"newdeal/ent/student"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeHymn      = "Hymn"
	TypeHymnsWork = "HymnsWork"
	TypeStudent   = "Student"
)

// HymnMutation represents an operation that mutates the Hymn nodes in the graph.
type HymnMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name_jp           *string
	name_kr           *string
	link              *string
	updated_time      *time.Time
	updated_user      *int64
	addupdated_user   *int64
	serif             *string
	visible_flg       *bool
	clearedFields     map[string]struct{}
	students          *int64
	clearedstudents   bool
	hymns_work        *int
	clearedhymns_work bool
	done              bool
	oldValue          func(context.Context) (*Hymn, error)
	predicates        []predicate.Hymn
}

var _ ent.Mutation = (*HymnMutation)(nil)

// hymnOption allows management of the mutation configuration using functional options.
type hymnOption func(*HymnMutation)

// newHymnMutation creates new mutation for the Hymn entity.
func newHymnMutation(c config, op Op, opts ...hymnOption) *HymnMutation {
	m := &HymnMutation{
		config:        c,
		op:            op,
		typ:           TypeHymn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHymnID sets the ID field of the mutation.
func withHymnID(id int64) hymnOption {
	return func(m *HymnMutation) {
		var (
			err   error
			once  sync.Once
			value *Hymn
		)
		m.oldValue = func(ctx context.Context) (*Hymn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hymn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHymn sets the old Hymn of the mutation.
func withHymn(node *Hymn) hymnOption {
	return func(m *HymnMutation) {
		m.oldValue = func(context.Context) (*Hymn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HymnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HymnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hymn entities.
func (m *HymnMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HymnMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HymnMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hymn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNameJp sets the "name_jp" field.
func (m *HymnMutation) SetNameJp(s string) {
	m.name_jp = &s
}

// NameJp returns the value of the "name_jp" field in the mutation.
func (m *HymnMutation) NameJp() (r string, exists bool) {
	v := m.name_jp
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJp returns the old "name_jp" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldNameJp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJp: %w", err)
	}
	return oldValue.NameJp, nil
}

// ResetNameJp resets all changes to the "name_jp" field.
func (m *HymnMutation) ResetNameJp() {
	m.name_jp = nil
}

// SetNameKr sets the "name_kr" field.
func (m *HymnMutation) SetNameKr(s string) {
	m.name_kr = &s
}

// NameKr returns the value of the "name_kr" field in the mutation.
func (m *HymnMutation) NameKr() (r string, exists bool) {
	v := m.name_kr
	if v == nil {
		return
	}
	return *v, true
}

// OldNameKr returns the old "name_kr" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldNameKr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameKr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameKr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameKr: %w", err)
	}
	return oldValue.NameKr, nil
}

// ResetNameKr resets all changes to the "name_kr" field.
func (m *HymnMutation) ResetNameKr() {
	m.name_kr = nil
}

// SetLink sets the "link" field.
func (m *HymnMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *HymnMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *HymnMutation) ResetLink() {
	m.link = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *HymnMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *HymnMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *HymnMutation) ResetUpdatedTime() {
	m.updated_time = nil
}

// SetUpdatedUser sets the "updated_user" field.
func (m *HymnMutation) SetUpdatedUser(i int64) {
	m.updated_user = &i
	m.addupdated_user = nil
}

// UpdatedUser returns the value of the "updated_user" field in the mutation.
func (m *HymnMutation) UpdatedUser() (r int64, exists bool) {
	v := m.updated_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedUser returns the old "updated_user" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldUpdatedUser(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedUser: %w", err)
	}
	return oldValue.UpdatedUser, nil
}

// AddUpdatedUser adds i to the "updated_user" field.
func (m *HymnMutation) AddUpdatedUser(i int64) {
	if m.addupdated_user != nil {
		*m.addupdated_user += i
	} else {
		m.addupdated_user = &i
	}
}

// AddedUpdatedUser returns the value that was added to the "updated_user" field in this mutation.
func (m *HymnMutation) AddedUpdatedUser() (r int64, exists bool) {
	v := m.addupdated_user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedUser resets all changes to the "updated_user" field.
func (m *HymnMutation) ResetUpdatedUser() {
	m.updated_user = nil
	m.addupdated_user = nil
}

// SetSerif sets the "serif" field.
func (m *HymnMutation) SetSerif(s string) {
	m.serif = &s
}

// Serif returns the value of the "serif" field in the mutation.
func (m *HymnMutation) Serif() (r string, exists bool) {
	v := m.serif
	if v == nil {
		return
	}
	return *v, true
}

// OldSerif returns the old "serif" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldSerif(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerif is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerif requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerif: %w", err)
	}
	return oldValue.Serif, nil
}

// ResetSerif resets all changes to the "serif" field.
func (m *HymnMutation) ResetSerif() {
	m.serif = nil
}

// SetVisibleFlg sets the "visible_flg" field.
func (m *HymnMutation) SetVisibleFlg(b bool) {
	m.visible_flg = &b
}

// VisibleFlg returns the value of the "visible_flg" field in the mutation.
func (m *HymnMutation) VisibleFlg() (r bool, exists bool) {
	v := m.visible_flg
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleFlg returns the old "visible_flg" field's value of the Hymn entity.
// If the Hymn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnMutation) OldVisibleFlg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleFlg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleFlg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleFlg: %w", err)
	}
	return oldValue.VisibleFlg, nil
}

// ResetVisibleFlg resets all changes to the "visible_flg" field.
func (m *HymnMutation) ResetVisibleFlg() {
	m.visible_flg = nil
}

// SetStudentsID sets the "students" edge to the Student entity by id.
func (m *HymnMutation) SetStudentsID(id int64) {
	m.students = &id
}

// ClearStudents clears the "students" edge to the Student entity.
func (m *HymnMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the Student entity was cleared.
func (m *HymnMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// StudentsID returns the "students" edge ID in the mutation.
func (m *HymnMutation) StudentsID() (id int64, exists bool) {
	if m.students != nil {
		return *m.students, true
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentsID instead. It exists only for internal usage by the builders.
func (m *HymnMutation) StudentsIDs() (ids []int64) {
	if id := m.students; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *HymnMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
}

// SetHymnsWorkID sets the "hymns_work" edge to the HymnsWork entity by id.
func (m *HymnMutation) SetHymnsWorkID(id int) {
	m.hymns_work = &id
}

// ClearHymnsWork clears the "hymns_work" edge to the HymnsWork entity.
func (m *HymnMutation) ClearHymnsWork() {
	m.clearedhymns_work = true
}

// HymnsWorkCleared reports if the "hymns_work" edge to the HymnsWork entity was cleared.
func (m *HymnMutation) HymnsWorkCleared() bool {
	return m.clearedhymns_work
}

// HymnsWorkID returns the "hymns_work" edge ID in the mutation.
func (m *HymnMutation) HymnsWorkID() (id int, exists bool) {
	if m.hymns_work != nil {
		return *m.hymns_work, true
	}
	return
}

// HymnsWorkIDs returns the "hymns_work" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HymnsWorkID instead. It exists only for internal usage by the builders.
func (m *HymnMutation) HymnsWorkIDs() (ids []int) {
	if id := m.hymns_work; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHymnsWork resets all changes to the "hymns_work" edge.
func (m *HymnMutation) ResetHymnsWork() {
	m.hymns_work = nil
	m.clearedhymns_work = false
}

// Where appends a list predicates to the HymnMutation builder.
func (m *HymnMutation) Where(ps ...predicate.Hymn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HymnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HymnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hymn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HymnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HymnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hymn).
func (m *HymnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HymnMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name_jp != nil {
		fields = append(fields, hymn.FieldNameJp)
	}
	if m.name_kr != nil {
		fields = append(fields, hymn.FieldNameKr)
	}
	if m.link != nil {
		fields = append(fields, hymn.FieldLink)
	}
	if m.updated_time != nil {
		fields = append(fields, hymn.FieldUpdatedTime)
	}
	if m.updated_user != nil {
		fields = append(fields, hymn.FieldUpdatedUser)
	}
	if m.serif != nil {
		fields = append(fields, hymn.FieldSerif)
	}
	if m.visible_flg != nil {
		fields = append(fields, hymn.FieldVisibleFlg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HymnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hymn.FieldNameJp:
		return m.NameJp()
	case hymn.FieldNameKr:
		return m.NameKr()
	case hymn.FieldLink:
		return m.Link()
	case hymn.FieldUpdatedTime:
		return m.UpdatedTime()
	case hymn.FieldUpdatedUser:
		return m.UpdatedUser()
	case hymn.FieldSerif:
		return m.Serif()
	case hymn.FieldVisibleFlg:
		return m.VisibleFlg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HymnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hymn.FieldNameJp:
		return m.OldNameJp(ctx)
	case hymn.FieldNameKr:
		return m.OldNameKr(ctx)
	case hymn.FieldLink:
		return m.OldLink(ctx)
	case hymn.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case hymn.FieldUpdatedUser:
		return m.OldUpdatedUser(ctx)
	case hymn.FieldSerif:
		return m.OldSerif(ctx)
	case hymn.FieldVisibleFlg:
		return m.OldVisibleFlg(ctx)
	}
	return nil, fmt.Errorf("unknown Hymn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hymn.FieldNameJp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJp(v)
		return nil
	case hymn.FieldNameKr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameKr(v)
		return nil
	case hymn.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case hymn.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case hymn.FieldUpdatedUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedUser(v)
		return nil
	case hymn.FieldSerif:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerif(v)
		return nil
	case hymn.FieldVisibleFlg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleFlg(v)
		return nil
	}
	return fmt.Errorf("unknown Hymn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HymnMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_user != nil {
		fields = append(fields, hymn.FieldUpdatedUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HymnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hymn.FieldUpdatedUser:
		return m.AddedUpdatedUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hymn.FieldUpdatedUser:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedUser(v)
		return nil
	}
	return fmt.Errorf("unknown Hymn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HymnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HymnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HymnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hymn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HymnMutation) ResetField(name string) error {
	switch name {
	case hymn.FieldNameJp:
		m.ResetNameJp()
		return nil
	case hymn.FieldNameKr:
		m.ResetNameKr()
		return nil
	case hymn.FieldLink:
		m.ResetLink()
		return nil
	case hymn.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case hymn.FieldUpdatedUser:
		m.ResetUpdatedUser()
		return nil
	case hymn.FieldSerif:
		m.ResetSerif()
		return nil
	case hymn.FieldVisibleFlg:
		m.ResetVisibleFlg()
		return nil
	}
	return fmt.Errorf("unknown Hymn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HymnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.students != nil {
		edges = append(edges, hymn.EdgeStudents)
	}
	if m.hymns_work != nil {
		edges = append(edges, hymn.EdgeHymnsWork)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HymnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hymn.EdgeStudents:
		if id := m.students; id != nil {
			return []ent.Value{*id}
		}
	case hymn.EdgeHymnsWork:
		if id := m.hymns_work; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HymnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HymnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HymnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudents {
		edges = append(edges, hymn.EdgeStudents)
	}
	if m.clearedhymns_work {
		edges = append(edges, hymn.EdgeHymnsWork)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HymnMutation) EdgeCleared(name string) bool {
	switch name {
	case hymn.EdgeStudents:
		return m.clearedstudents
	case hymn.EdgeHymnsWork:
		return m.clearedhymns_work
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HymnMutation) ClearEdge(name string) error {
	switch name {
	case hymn.EdgeStudents:
		m.ClearStudents()
		return nil
	case hymn.EdgeHymnsWork:
		m.ClearHymnsWork()
		return nil
	}
	return fmt.Errorf("unknown Hymn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HymnMutation) ResetEdge(name string) error {
	switch name {
	case hymn.EdgeStudents:
		m.ResetStudents()
		return nil
	case hymn.EdgeHymnsWork:
		m.ResetHymnsWork()
		return nil
	}
	return fmt.Errorf("unknown Hymn edge %s", name)
}

// HymnsWorkMutation represents an operation that mutates the HymnsWork nodes in the graph.
type HymnsWorkMutation struct {
	config
	op               Op
	typ              string
	id               *int
	work_id          *int64
	addwork_id       *int64
	score            *[]byte
	name_jp_rational *string
	updated_time     *time.Time
	biko             *string
	clearedFields    map[string]struct{}
	hymns            *int64
	clearedhymns     bool
	done             bool
	oldValue         func(context.Context) (*HymnsWork, error)
	predicates       []predicate.HymnsWork
}

var _ ent.Mutation = (*HymnsWorkMutation)(nil)

// hymnsworkOption allows management of the mutation configuration using functional options.
type hymnsworkOption func(*HymnsWorkMutation)

// newHymnsWorkMutation creates new mutation for the HymnsWork entity.
func newHymnsWorkMutation(c config, op Op, opts ...hymnsworkOption) *HymnsWorkMutation {
	m := &HymnsWorkMutation{
		config:        c,
		op:            op,
		typ:           TypeHymnsWork,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHymnsWorkID sets the ID field of the mutation.
func withHymnsWorkID(id int) hymnsworkOption {
	return func(m *HymnsWorkMutation) {
		var (
			err   error
			once  sync.Once
			value *HymnsWork
		)
		m.oldValue = func(ctx context.Context) (*HymnsWork, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HymnsWork.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHymnsWork sets the old HymnsWork of the mutation.
func withHymnsWork(node *HymnsWork) hymnsworkOption {
	return func(m *HymnsWorkMutation) {
		m.oldValue = func(context.Context) (*HymnsWork, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HymnsWorkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HymnsWorkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HymnsWorkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HymnsWorkMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HymnsWork.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWorkID sets the "work_id" field.
func (m *HymnsWorkMutation) SetWorkID(i int64) {
	m.work_id = &i
	m.addwork_id = nil
}

// WorkID returns the value of the "work_id" field in the mutation.
func (m *HymnsWorkMutation) WorkID() (r int64, exists bool) {
	v := m.work_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkID returns the old "work_id" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldWorkID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkID: %w", err)
	}
	return oldValue.WorkID, nil
}

// AddWorkID adds i to the "work_id" field.
func (m *HymnsWorkMutation) AddWorkID(i int64) {
	if m.addwork_id != nil {
		*m.addwork_id += i
	} else {
		m.addwork_id = &i
	}
}

// AddedWorkID returns the value that was added to the "work_id" field in this mutation.
func (m *HymnsWorkMutation) AddedWorkID() (r int64, exists bool) {
	v := m.addwork_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkID resets all changes to the "work_id" field.
func (m *HymnsWorkMutation) ResetWorkID() {
	m.work_id = nil
	m.addwork_id = nil
}

// SetScore sets the "score" field.
func (m *HymnsWorkMutation) SetScore(b []byte) {
	m.score = &b
}

// Score returns the value of the "score" field in the mutation.
func (m *HymnsWorkMutation) Score() (r []byte, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldScore(ctx context.Context) (v *[]byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// ResetScore resets all changes to the "score" field.
func (m *HymnsWorkMutation) ResetScore() {
	m.score = nil
}

// SetNameJpRational sets the "name_jp_rational" field.
func (m *HymnsWorkMutation) SetNameJpRational(s string) {
	m.name_jp_rational = &s
}

// NameJpRational returns the value of the "name_jp_rational" field in the mutation.
func (m *HymnsWorkMutation) NameJpRational() (r string, exists bool) {
	v := m.name_jp_rational
	if v == nil {
		return
	}
	return *v, true
}

// OldNameJpRational returns the old "name_jp_rational" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldNameJpRational(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameJpRational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameJpRational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameJpRational: %w", err)
	}
	return oldValue.NameJpRational, nil
}

// ResetNameJpRational resets all changes to the "name_jp_rational" field.
func (m *HymnsWorkMutation) ResetNameJpRational() {
	m.name_jp_rational = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *HymnsWorkMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *HymnsWorkMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldUpdatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *HymnsWorkMutation) ResetUpdatedTime() {
	m.updated_time = nil
}

// SetBiko sets the "biko" field.
func (m *HymnsWorkMutation) SetBiko(s string) {
	m.biko = &s
}

// Biko returns the value of the "biko" field in the mutation.
func (m *HymnsWorkMutation) Biko() (r string, exists bool) {
	v := m.biko
	if v == nil {
		return
	}
	return *v, true
}

// OldBiko returns the old "biko" field's value of the HymnsWork entity.
// If the HymnsWork object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HymnsWorkMutation) OldBiko(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBiko is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBiko requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBiko: %w", err)
	}
	return oldValue.Biko, nil
}

// ResetBiko resets all changes to the "biko" field.
func (m *HymnsWorkMutation) ResetBiko() {
	m.biko = nil
}

// SetHymnsID sets the "hymns" edge to the Hymn entity by id.
func (m *HymnsWorkMutation) SetHymnsID(id int64) {
	m.hymns = &id
}

// ClearHymns clears the "hymns" edge to the Hymn entity.
func (m *HymnsWorkMutation) ClearHymns() {
	m.clearedhymns = true
}

// HymnsCleared reports if the "hymns" edge to the Hymn entity was cleared.
func (m *HymnsWorkMutation) HymnsCleared() bool {
	return m.clearedhymns
}

// HymnsID returns the "hymns" edge ID in the mutation.
func (m *HymnsWorkMutation) HymnsID() (id int64, exists bool) {
	if m.hymns != nil {
		return *m.hymns, true
	}
	return
}

// HymnsIDs returns the "hymns" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HymnsID instead. It exists only for internal usage by the builders.
func (m *HymnsWorkMutation) HymnsIDs() (ids []int64) {
	if id := m.hymns; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHymns resets all changes to the "hymns" edge.
func (m *HymnsWorkMutation) ResetHymns() {
	m.hymns = nil
	m.clearedhymns = false
}

// Where appends a list predicates to the HymnsWorkMutation builder.
func (m *HymnsWorkMutation) Where(ps ...predicate.HymnsWork) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HymnsWorkMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HymnsWorkMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HymnsWork, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HymnsWorkMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HymnsWorkMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HymnsWork).
func (m *HymnsWorkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HymnsWorkMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.work_id != nil {
		fields = append(fields, hymnswork.FieldWorkID)
	}
	if m.score != nil {
		fields = append(fields, hymnswork.FieldScore)
	}
	if m.name_jp_rational != nil {
		fields = append(fields, hymnswork.FieldNameJpRational)
	}
	if m.updated_time != nil {
		fields = append(fields, hymnswork.FieldUpdatedTime)
	}
	if m.biko != nil {
		fields = append(fields, hymnswork.FieldBiko)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HymnsWorkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hymnswork.FieldWorkID:
		return m.WorkID()
	case hymnswork.FieldScore:
		return m.Score()
	case hymnswork.FieldNameJpRational:
		return m.NameJpRational()
	case hymnswork.FieldUpdatedTime:
		return m.UpdatedTime()
	case hymnswork.FieldBiko:
		return m.Biko()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HymnsWorkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hymnswork.FieldWorkID:
		return m.OldWorkID(ctx)
	case hymnswork.FieldScore:
		return m.OldScore(ctx)
	case hymnswork.FieldNameJpRational:
		return m.OldNameJpRational(ctx)
	case hymnswork.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case hymnswork.FieldBiko:
		return m.OldBiko(ctx)
	}
	return nil, fmt.Errorf("unknown HymnsWork field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnsWorkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hymnswork.FieldWorkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkID(v)
		return nil
	case hymnswork.FieldScore:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case hymnswork.FieldNameJpRational:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameJpRational(v)
		return nil
	case hymnswork.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case hymnswork.FieldBiko:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBiko(v)
		return nil
	}
	return fmt.Errorf("unknown HymnsWork field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HymnsWorkMutation) AddedFields() []string {
	var fields []string
	if m.addwork_id != nil {
		fields = append(fields, hymnswork.FieldWorkID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HymnsWorkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hymnswork.FieldWorkID:
		return m.AddedWorkID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HymnsWorkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hymnswork.FieldWorkID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkID(v)
		return nil
	}
	return fmt.Errorf("unknown HymnsWork numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HymnsWorkMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HymnsWorkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HymnsWorkMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HymnsWork nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HymnsWorkMutation) ResetField(name string) error {
	switch name {
	case hymnswork.FieldWorkID:
		m.ResetWorkID()
		return nil
	case hymnswork.FieldScore:
		m.ResetScore()
		return nil
	case hymnswork.FieldNameJpRational:
		m.ResetNameJpRational()
		return nil
	case hymnswork.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case hymnswork.FieldBiko:
		m.ResetBiko()
		return nil
	}
	return fmt.Errorf("unknown HymnsWork field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HymnsWorkMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hymns != nil {
		edges = append(edges, hymnswork.EdgeHymns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HymnsWorkMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hymnswork.EdgeHymns:
		if id := m.hymns; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HymnsWorkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HymnsWorkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HymnsWorkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhymns {
		edges = append(edges, hymnswork.EdgeHymns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HymnsWorkMutation) EdgeCleared(name string) bool {
	switch name {
	case hymnswork.EdgeHymns:
		return m.clearedhymns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HymnsWorkMutation) ClearEdge(name string) error {
	switch name {
	case hymnswork.EdgeHymns:
		m.ClearHymns()
		return nil
	}
	return fmt.Errorf("unknown HymnsWork unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HymnsWorkMutation) ResetEdge(name string) error {
	switch name {
	case hymnswork.EdgeHymns:
		m.ResetHymns()
		return nil
	}
	return fmt.Errorf("unknown HymnsWork edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	login_account *string
	password      *string
	username      *string
	date_of_birth *time.Time
	email         *string
	updated_time  *time.Time
	visible_flg   *bool
	clearedFields map[string]struct{}
	hymns         map[int64]struct{}
	removedhymns  map[int64]struct{}
	clearedhymns  bool
	done          bool
	oldValue      func(context.Context) (*Student, error)
	predicates    []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id int64) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Student.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLoginAccount sets the "login_account" field.
func (m *StudentMutation) SetLoginAccount(s string) {
	m.login_account = &s
}

// LoginAccount returns the value of the "login_account" field in the mutation.
func (m *StudentMutation) LoginAccount() (r string, exists bool) {
	v := m.login_account
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginAccount returns the old "login_account" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldLoginAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginAccount: %w", err)
	}
	return oldValue.LoginAccount, nil
}

// ResetLoginAccount resets all changes to the "login_account" field.
func (m *StudentMutation) ResetLoginAccount() {
	m.login_account = nil
}

// SetPassword sets the "password" field.
func (m *StudentMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *StudentMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *StudentMutation) ResetPassword() {
	m.password = nil
}

// SetUsername sets the "username" field.
func (m *StudentMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *StudentMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *StudentMutation) ResetUsername() {
	m.username = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *StudentMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *StudentMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *StudentMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
}

// SetEmail sets the "email" field.
func (m *StudentMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StudentMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StudentMutation) ResetEmail() {
	m.email = nil
}

// SetUpdatedTime sets the "updated_time" field.
func (m *StudentMutation) SetUpdatedTime(t time.Time) {
	m.updated_time = &t
}

// UpdatedTime returns the value of the "updated_time" field in the mutation.
func (m *StudentMutation) UpdatedTime() (r time.Time, exists bool) {
	v := m.updated_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedTime returns the old "updated_time" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUpdatedTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedTime: %w", err)
	}
	return oldValue.UpdatedTime, nil
}

// ResetUpdatedTime resets all changes to the "updated_time" field.
func (m *StudentMutation) ResetUpdatedTime() {
	m.updated_time = nil
}

// SetVisibleFlg sets the "visible_flg" field.
func (m *StudentMutation) SetVisibleFlg(b bool) {
	m.visible_flg = &b
}

// VisibleFlg returns the value of the "visible_flg" field in the mutation.
func (m *StudentMutation) VisibleFlg() (r bool, exists bool) {
	v := m.visible_flg
	if v == nil {
		return
	}
	return *v, true
}

// OldVisibleFlg returns the old "visible_flg" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldVisibleFlg(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisibleFlg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisibleFlg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisibleFlg: %w", err)
	}
	return oldValue.VisibleFlg, nil
}

// ResetVisibleFlg resets all changes to the "visible_flg" field.
func (m *StudentMutation) ResetVisibleFlg() {
	m.visible_flg = nil
}

// AddHymnIDs adds the "hymns" edge to the Hymn entity by ids.
func (m *StudentMutation) AddHymnIDs(ids ...int64) {
	if m.hymns == nil {
		m.hymns = make(map[int64]struct{})
	}
	for i := range ids {
		m.hymns[ids[i]] = struct{}{}
	}
}

// ClearHymns clears the "hymns" edge to the Hymn entity.
func (m *StudentMutation) ClearHymns() {
	m.clearedhymns = true
}

// HymnsCleared reports if the "hymns" edge to the Hymn entity was cleared.
func (m *StudentMutation) HymnsCleared() bool {
	return m.clearedhymns
}

// RemoveHymnIDs removes the "hymns" edge to the Hymn entity by IDs.
func (m *StudentMutation) RemoveHymnIDs(ids ...int64) {
	if m.removedhymns == nil {
		m.removedhymns = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.hymns, ids[i])
		m.removedhymns[ids[i]] = struct{}{}
	}
}

// RemovedHymns returns the removed IDs of the "hymns" edge to the Hymn entity.
func (m *StudentMutation) RemovedHymnsIDs() (ids []int64) {
	for id := range m.removedhymns {
		ids = append(ids, id)
	}
	return
}

// HymnsIDs returns the "hymns" edge IDs in the mutation.
func (m *StudentMutation) HymnsIDs() (ids []int64) {
	for id := range m.hymns {
		ids = append(ids, id)
	}
	return
}

// ResetHymns resets all changes to the "hymns" edge.
func (m *StudentMutation) ResetHymns() {
	m.hymns = nil
	m.clearedhymns = false
	m.removedhymns = nil
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StudentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StudentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Student, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StudentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.login_account != nil {
		fields = append(fields, student.FieldLoginAccount)
	}
	if m.password != nil {
		fields = append(fields, student.FieldPassword)
	}
	if m.username != nil {
		fields = append(fields, student.FieldUsername)
	}
	if m.date_of_birth != nil {
		fields = append(fields, student.FieldDateOfBirth)
	}
	if m.email != nil {
		fields = append(fields, student.FieldEmail)
	}
	if m.updated_time != nil {
		fields = append(fields, student.FieldUpdatedTime)
	}
	if m.visible_flg != nil {
		fields = append(fields, student.FieldVisibleFlg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldLoginAccount:
		return m.LoginAccount()
	case student.FieldPassword:
		return m.Password()
	case student.FieldUsername:
		return m.Username()
	case student.FieldDateOfBirth:
		return m.DateOfBirth()
	case student.FieldEmail:
		return m.Email()
	case student.FieldUpdatedTime:
		return m.UpdatedTime()
	case student.FieldVisibleFlg:
		return m.VisibleFlg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldLoginAccount:
		return m.OldLoginAccount(ctx)
	case student.FieldPassword:
		return m.OldPassword(ctx)
	case student.FieldUsername:
		return m.OldUsername(ctx)
	case student.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case student.FieldEmail:
		return m.OldEmail(ctx)
	case student.FieldUpdatedTime:
		return m.OldUpdatedTime(ctx)
	case student.FieldVisibleFlg:
		return m.OldVisibleFlg(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldLoginAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginAccount(v)
		return nil
	case student.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case student.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case student.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case student.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case student.FieldUpdatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedTime(v)
		return nil
	case student.FieldVisibleFlg:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisibleFlg(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldLoginAccount:
		m.ResetLoginAccount()
		return nil
	case student.FieldPassword:
		m.ResetPassword()
		return nil
	case student.FieldUsername:
		m.ResetUsername()
		return nil
	case student.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case student.FieldEmail:
		m.ResetEmail()
		return nil
	case student.FieldUpdatedTime:
		m.ResetUpdatedTime()
		return nil
	case student.FieldVisibleFlg:
		m.ResetVisibleFlg()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.hymns != nil {
		edges = append(edges, student.EdgeHymns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeHymns:
		ids := make([]ent.Value, 0, len(m.hymns))
		for id := range m.hymns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhymns != nil {
		edges = append(edges, student.EdgeHymns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeHymns:
		ids := make([]ent.Value, 0, len(m.removedhymns))
		for id := range m.removedhymns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhymns {
		edges = append(edges, student.EdgeHymns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeHymns:
		return m.clearedhymns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeHymns:
		m.ResetHymns()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}
